---
layout: post
title: "MalwareMustDie MK64 样本分析"
---

# 0x00 背景

这次捕获样本的亮点在于有个自保过程，也是有一定的Flood功能，[VT](https://www.virustotal.com/#/file/69b868bc6fbb23c3cae9615f22abce546b041df8f209ed1ebd1323d77ecd878b/detection)上监测如下，但行为和标注出来的家族都不太一样，就暂且将其称为MK64吧，本文主要是静态分析动态验证一下，MMD：

<!-- more -->

![][1]

# 0x01 特征

![][2]

## 守护进程

通过init_daemon函数设置成为守护进程，切换至/tmp目录。有个小技巧就是patch该函数就可以看到程序在开发过程中的调试输出（如果有的话），便于理解程序功能。

## 进程互斥

在CSocketManager::Initalize函数中会bind 29123或29124端口作为互斥条件，失败则退出。

## 自启动

在DefaultStartUp函数中通过system函数执行以下命令：

```
echo 'DDosClient &'>> /etc/init.d/rc.local;echo >> /etc/init.d/rc.local
```

## 进程自保

在CopyAndRun函数中，其会drop处一个dbuspm-session的ELF文件，添加执行权限并执行：

![][3]

注意这里通过参数向dbuspm-session中传递了其pid，而在dbuspm-session中则会将该值保存到全局变量pid中，并会实时监测“父进程”是否存在，不存在则再次执行原样本：

![][4]

dbuspm-session也会把自己的pid传递给原样本的RecvUsr1Signal sa_handler，同样是“认贼作父”，这样两个进程就成为了监控重启彼此的天使宝宝。

dbuspm-session中还cp备份原样本实现低级自保：

![][5]

## C&C

从小节最开始的图片可以看到，样本会fork执行初始化，所以会有两个C&C地址，子进程的初始化还会sleep 2天后在进行。对于连接的地址稍微编码了一下：

![][6]

解码后为：

```
118.193.184.221:29135
www.jyzs88.com:29135
```

jyzs88解析地址为127.0.0.1目测已被某IDC回收，118.193.184.221反查域名又是国内的大佬？：

![][7]

# 0x02 功能

![][8]

## SendOnlineInfo

当连接上C&C后会发送全局变量m_LoginInfo 392字节内容，其中包括被控端的utsname.sysname、utsname.release、NetChad、Memory、CpuSpeed、PackageLoad、WorkStatus、SendStatus等信息：

![][9]

在GetOnlineInfo函数中会开启新线程，一旦连接上就While 1循环发送m_LoginInfo信息。

## DisposeMessage

### 变量设置

1. DDos SET：设置在DDOS过程中某些字段内容。
2. COMMAND_DDOS_STOP：设置Stop相关全局变量停止攻击。
3. SetDNS：接收并设置DNS地址至全局DNS_Servers数组，但无其他交叉引用。
4. CpuLimit：设置CpuSpeedLimit、CheckTime限制攻击过程中Cpu的使用。
5. 其他：替换MK64为其他字符串。

### 执行命令

Cmd Arrive

接收cmd字符串fork后执行。

### 发送数据包

SendForgeUdp

顾名思义，可以设置源端口会发送伪造的udp包至C&C：

![][10]

StartDDosTask

DDOS功能有SYN_Flood、UDP_Flood、ICMP_Flood、DNS_Flood四种，可以多线程进行攻击：

![][11]

但在Flood之前会开线程调用CpuLimitor方法设置实例的数据成员，也是前面提到的：如果开启了doCpuLimit，会将实时的CpuSpeed和限制的CpuSpeedLimit对比，超过则usleep对应的CheckTime。同时还会设置攻击的时间。在线程开始攻击后，还会调用Packagecalculator方法记录已加载的数据包。

# 0x03 修复

虽然该样本的进程自保看似凶相，但还是通过system函数执行原二进制文件，所以先删样本再杀死进程就可以斩草除根了，当然也不要忘记恢复你的rc.local文件哦。欢迎大牛指点，学者轻拍，道友交流。

[1]: https://wx1.sinaimg.cn/large/ee2fecafly1fo4ozqju3qj20ve0exdh5.jpg
[2]: https://wx1.sinaimg.cn/large/ee2fecafly1fo4ozri8gej20pn07o74n.jpg
[3]: https://wx3.sinaimg.cn/large/ee2fecafly1fo4ozsecugj20i608jt8y.jpg
[4]: https://wx2.sinaimg.cn/large/ee2fecafly1fo4ozt1rezj20jp09uwep.jpg
[5]: https://wx4.sinaimg.cn/large/ee2fecafly1fo4ozu984hj20no068dg8.jpg
[6]: https://wx4.sinaimg.cn/large/ee2fecafly1fo4ozuu062j20cl036jr8.jpg
[7]: https://wx4.sinaimg.cn/large/ee2fecafly1fo4ozvlicij20tu0dz74k.jpg
[8]: https://wx2.sinaimg.cn/large/ee2fecafly1fo4ozw800zj20is08174h.jpg
[9]: https://wx2.sinaimg.cn/large/ee2fecafly1fo4ozxf04jj20gx0bt74y.jpg
[10]: https://wx3.sinaimg.cn/large/ee2fecafly1fo4ozyk0apj20rl07egmu.jpg
[11]: https://wx1.sinaimg.cn/large/ee2fecafly1fo4ozz3pz7j20pk05yt8t.jpg
