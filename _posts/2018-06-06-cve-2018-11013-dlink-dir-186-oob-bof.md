---
layout: post
title: "CVE-2018-11013 D-Link DIR-816 OOB BoF"
---

# 0x00 Abstract

Well, it is time to practice my poor English by writing internationalized post, not in the future. I would appreciate it if you could point me out the inappropriate usage of English. Return to the rop, [CVE-2018-11013](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2018-11013) is a stack based BoF in D-Link DIR-816 router, the author has exploited it in an interesting way, which is so abstract that I explored as fllows.

<!-- more -->

# 0x01 Preparation

* Firmware: [DIR-816A2_v1.10CNB03_D77137.img](http://support.dlink.com.cn/download.ashx?file=5099)
* Operating System: Kali with correct binwalk
* Debugger: [pwndbg](https://github.com/pwndbg/pwndbg), [gdb-multiarch](https://reverseengineering.stackexchange.com/questions/8829/cross-debugging-for-arm-mips-elf-with-qemu-toolchain)

As the original [blog](https://0x3f97.github.io/exploit/2018/05/11/Dlink-DIR-816-stack-based-buffer-overflow-anaysis/) said, it is convenient to debug http service with internal `telnetd` in low version firmware. We can find the differences by binwalking them:

![][1]

Although the telnetd isn’t started by default, we can still turn it on by accessing d_telnet.asp, just looks like a kind of backdoor, isn’t it?

![][2]

What we should do is to upload gdbserver.mipsle using its tftp binary and debug it whenever you want.

# 0x02 Detail

The vulnerability in websRedirect function is the OOB write, the loop storing byte to stack doesn’t stop until it meets byte ':' or '\n':

![][3]

At this time, $a1 is the loop counter, $a0 is the source HTTP_HOST in HTTP request header, and $s2 is the var_E0.When the host header is larger than (0xE0-0x40-0x4) bytes, the $ra register will be overwrited.

After sending out your AAAA stuff, you will figure out that the stack in high address is still accessed in later instruction:

![][4]

Therefore, the corresponding positions of var_30 and var_2C should be an accessable address.

With the accurate offset, the final step is to construct rop or shellcode. It is also the time to checksec goahead binary:

![][5]

The binary is naked and the heap is also executable.The ASLR on the system is 1, and the heap address is not changeable:

![][6]

Witout information leak, we can’t use the gadget in libuClibc, the mipsle architecture and host '\x00' block make us use only once ret2somewhere. The author’s solution is to generate a request larger than 64k, the http data will be malloced to the unchangeable heap, the final jump will be much easy too. What a good idea!

The reason why the limit is 64k is obvious in goahead’s source [code](https://github.com/embedthis/goahead/blob/105fd4f58f1a81a6611dcb27ab42f2e73bf62ef2/src/alloc.c#L129), which I search for a long time:

![][7]

The [WEBS_DEFAULT_MEM](https://github.com/embedthis/goahead/blob/dc6068618287bbb0919195140068ab3656964c9e/src/goahead.h#L745) is just the limit 64k. Thanks to msfvenom, the shellcode won’t be a challenge:

![][8]

We can exploit it now:

![][9] 

# 0x03 Conclusion

For fresh water comes from the source, it is a good idea and chance to learn the exploitation in the IoT world.

[1]: https://wx2.sinaimg.cn/large/ee2fecafly1fs0r59jaxvj20k105440a.jpg
[2]: https://wx3.sinaimg.cn/large/ee2fecafly1fs0r5a8mzpj20n808374l.jpg
[3]: https://wx2.sinaimg.cn/large/ee2fecafly1fs0r5bf582j20s30jqgn4.jpg
[4]: https://wx4.sinaimg.cn/large/ee2fecafly1fs0r5ct3lqj20s30fjt9y.jpg
[5]: https://wx1.sinaimg.cn/large/ee2fecafly1fs0r5ic06qj20k30h5gtx.jpg
[6]: https://wx1.sinaimg.cn/large/ee2fecafly1fs0r5mo1cuj20k20cz100.jpg
[7]: https://wx1.sinaimg.cn/large/ee2fecafly1fs0r5nfw81j20j70crq3f.jpg
[8]: https://wx4.sinaimg.cn/large/ee2fecafly1fs0r5sca5oj20k10cg11v.jpg
[9]: https://wx1.sinaimg.cn/large/ee2fecafly1fs0r5stswcj20fm068wec.jpg
