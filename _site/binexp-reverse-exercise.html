<h1 id="x00-">0x00 前言</h1>

<p>怎么着都得去学习接触二进制，才能算是踏入安全的领域，所以就跟着<a href="http://security.cs.rpi.edu/courses/binexp-spring2015/">Modern Binary Exploitation</a>加强一下学习，主要还是以探究做练习为主，争取不拖团队后腿。（本次练习的题目是课程前四周涉及的内容）</p>

<h1 id="x01-crackme">0x01 Crackme</h1>

<p>在crackme0x00a中直接加载进入IDA，主要逻辑为输入密码并判断正误，牛刀小试。</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/1.png" alt="" /></p>

<p>在crackme0x00b中，程序和0x00a类似，不过是使用_wcscmp来比较字符串，但在scanf中也有%ls修饰输入为宽字节，在Linux-x86下为utf-32编码，直接跟进看是哪些字符就好：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/2.png" alt="" /></p>

<p>不仔细的话就会先入为主被IDA的注释给坑了，也可以在hex-view查看相关数据：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/3.png" alt="" /></p>

<p>crackme0x01则是比较输入的数字，同样easy：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/4.png" alt="" /></p>

<p>Crackme0x02进行了一下加法和乘法的运算：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/5.png" alt="" /></p>

<p>Crackme0x04也是先输入一段字符串，然后调用check函数，check检测字符串的长度是否为15就ok了：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/6.png" alt="" /></p>

<p>Crackme0x03的前半段逻辑一样，进行加法和乘法的运算后，调用test(int(s),338724)函数，很明显输入相等即可成功：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/7.png" alt="" /></p>

<p>不过这里将输出“加密”了一下，跟进shift函数：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/8.png" alt="" /></p>

<p>所以将字符统一前移3位即可显形。</p>

<p>Crackeme0x05中输入字符串后调用check函数：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/9.png" alt="" /></p>

<p>Check函数检测输入的各个字符上的数字之和是否为16，再决定调用parell函数与否，在parell函数中：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/10.png" alt="" /></p>

<p>将输入的数字和1按位相与，数值不是奇数即可pass：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/11.png" alt="" /></p>

<p>Crackme0x06和逻辑和0x05类似，都有check和parell函数，并且传入了程序启动时的envp参数，并在parell函数中增加了dummy函数：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/12.png" alt="" /></p>

<p>只有dummy函数返回真值，并且输入的数字各个位数和为16且不是奇数才算成功。在dummy函数中：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/13.png" alt="" /></p>

<p>在函数调用伊始，栈中布局为EBP,RETURN ADDRESS, int(s),envp，所以说ebp+arg_4即ebp+0Ch指向的就是envp。那么函数的逻辑就显而易见了，循环环境变量数组，如果有”LOL”开头的环境变量就返回1，否则返回0。</p>

<p>我们允许程序前添加对应的环境变量，再按0x05的套路来就crack了：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/14.png" alt="" /></p>

<p>Crackme0x07的逻辑和0x06类似，不过要求各个位数和为24，而且传入的参数变为arg_8，应该和linux下程序的启动有关，可见<a href="http://www.jianshu.com/p/eb39eac9d82e">这里</a>：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/15.png" alt="" /></p>

<p>其他的按部就班就好：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/16.png" alt="" /></p>

<p>Crackme0x08和0x07一样：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/17.png" alt="" /></p>

<p>Crackme0x09和0x08一样，就不赘述了。</p>

<h1 id="x02-lab">0x02 Lab</h1>

<p>Lab1程序开始初始化var_1，然后就是常规的让我们输入密码判断正确性：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/18.png" alt="" /></p>

<p>之后的流程如下图：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/19.png" alt="" /></p>

<p>loc_804853E和loc_8048539处的代码可以理解为一直循环到输入字符串的末尾，然后每个字符都进入loc_80484FF的比较逻辑，如果每个字符都满足<code>s[var_1] == var_1 ^ storedpass[var_1]</code>，那就是妥妥的成功了。所以就有：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/20.png" alt="" /></p>

<p>Lab2的验证流程和Lab1类似，也是将存储好的字符串进行一定的变换，再和我们输入的密码比较是否相符：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/21.png" alt="" /></p>

<p>从汇编代码来看其中可能是进行了一个除法的操作，在计算出MagicNumber后可以得到关键的比较逻辑<code>if(i+1)^storedpass[i] == s[i])</code>，对应还原即可：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/22.png" alt="" /></p>

<p>Lab3的主要逻辑是需要我们输入长度大于5的用户名，然后逆向出相应的序列号才算成功，汇编上的表现就是将内部生成的序列号和我们输入的进行对比：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/23.png" alt="" /></p>

<p>其中dword_804A034处保存的是我们输入的序列号：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/24.png" alt="" /></p>

<p>dword_804A038处保存的是内部算法生成的序列号：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/25.png" alt="" /></p>

<p>遇到的第一个坑就是这里不知道dword_804A038的初始值，在经历了patch程序去除ptrace的反调试又载入gdb没有相应的符号表和IDA远程调试无法attach程序后，最终还是知道了.bss段的存在，dword_804A038在程序中是全局变量的存在，所以其初始值为0：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/26.png" alt="" /></p>

<p>那么一切都很完美了，按照代码的逻辑即可计算出相应的序列码，可是’larry’对应的468总是不对，而偶然尝试的’00000’对应的序列码0又是成立的，很是奇怪：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/27.png" alt="" /></p>

<p>隐约感觉到问题还是可能出在<code> ([dword_804A038] + name[i]) ^ name[(i-1)%strlen(name)]</code>这一句代码中，于是在参考<a href="http://blog.csdn.net/wjcsharp/article/details/11075993">这里</a>后，修改了sp的值，再F5看汇编的伪代码，结果和我分析的逻辑是一样的，还是很困惑：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/28.png" alt="" /></p>

<p>最后还是觉得应该从汇编的角度去看，觉得问题可能会存在于汇编的div中，探索一番发现汇编的取余数和C语言及Python的取模还是有区别的。实验一番发现，在Python里-1%5的结果为4，在C语言里-1%5的结果为-1，而从汇编的角度来看第一次异或的值就应该是<code>name[0xffffffff]%strlen(name)]</code>，所以’larry’对应的序列号就是297，实验如下：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20170725/29.png" alt="" /></p>

<h1 id="x03-">0x03 总结</h1>

<p>逆向分析C语言相关的题目时，多看看《C++反汇编与逆向分析技术揭秘》这本书也是挺好的，接触得多了也就能肉眼翻译出汇编代码对应的高级语言代码，多看多验证自己的想法总是有益的，对于汇编指令的理解和gdb动态调试方面还需要加强，IDA用得熟练也是必须要做到的。</p>

